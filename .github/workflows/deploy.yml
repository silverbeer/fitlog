name: üöÄ Deploy Fitlog API

on:
  push:
    branches: [main, feature/v2-cloud-migration]
    paths:
      - 'api/**'
      - 'fitlog/**'
      - 'pyproject.toml'
      - '.github/workflows/deploy.yml'
  pull_request:
    branches: [main]
    paths:
      - 'api/**'
      - 'fitlog/**'
      - 'pyproject.toml'

env:
  AWS_REGION: us-east-1
  LAMBDA_FUNCTION_NAME: fitlog-dev-api
  PYTHON_VERSION: '3.13'

jobs:
  test:
    name: üß™ Test Application
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üêç Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: üì¶ Install UV
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        
    - name: üîß Install dependencies
      run: |
        uv venv
        source .venv/bin/activate
        uv pip install -e ".[dev,test]"
        
    - name: üßπ Lint with ruff
      run: |
        source .venv/bin/activate
        uv run ruff check .
        
    - name: üé® Format check with black
      run: |
        source .venv/bin/activate
        uv run black --check .
        
    - name: üîç Type check with mypy
      run: |
        source .venv/bin/activate
        uv run mypy fitlog/ --ignore-missing-imports
        
    - name: üß™ Run tests
      run: |
        source .venv/bin/activate
        uv run pytest -v
        
  deploy:
    name: üöÄ Deploy to AWS Lambda
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/feature/v2-cloud-migration'
    # environment: production  # Add this later in GitHub repo settings for deployment protection
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üêç Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üì¶ Install UV and dependencies
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        uv venv
        source .venv/bin/activate
        uv pip install -e ".[cloud]"
        
    - name: üì¶ Create Lambda deployment package
      run: |
        # Create deployment directory
        mkdir -p lambda-deploy
        
        # Copy FastAPI application code
        cp -r api/* lambda-deploy/ 2>/dev/null || echo "No api/ directory yet"
        cp -r fitlog lambda-deploy/
        
        # Install dependencies to deployment directory
        source .venv/bin/activate
        pip install \
          fastapi \
          uvicorn \
          duckdb \
          pydantic \
          boto3 \
          mangum \
          --target lambda-deploy/
          
        # Create Lambda handler if it doesn't exist
        if [ ! -f lambda-deploy/main.py ]; then
          cat > lambda-deploy/main.py << 'EOF'
        import json
        from mangum import Mangum
        from fastapi import FastAPI
        
        # Import your fitlog modules here
        # from fitlog.models import Run, Pushup
        # from fitlog.db import init_db
        
        app = FastAPI(
            title="Fitlog API",
            description="Personal exercise tracking API",
            version="2.0.0"
        )
        
        @app.get("/")
        async def health_check():
            return {
                "message": "Fitlog API v2.0.0",
                "status": "healthy",
                "environment": "cloud"
            }
            
        @app.get("/runs")
        async def get_runs():
            return {"message": "Get runs endpoint - implement with DuckDB S3"}
            
        @app.post("/runs")
        async def create_run():
            return {"message": "Create run endpoint - implement with DuckDB S3"}
            
        @app.get("/pushups")
        async def get_pushups():
            return {"message": "Get pushups endpoint - implement with DuckDB S3"}
            
        @app.post("/pushups")
        async def create_pushups():
            return {"message": "Create pushups endpoint - implement with DuckDB S3"}
            
        @app.get("/activities/status")
        async def get_status():
            return {"message": "Activity status endpoint - implement with DuckDB S3"}
        
        # Lambda handler
        handler = Mangum(app)
        EOF
        fi
        
        # Create deployment zip
        cd lambda-deploy
        zip -r ../lambda-deployment.zip . -x "*.pyc" "*/__pycache__/*"
        cd ..
        
    - name: üöÄ Deploy to Lambda
      run: |
        aws lambda update-function-code \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --zip-file fileb://lambda-deployment.zip \
          --region ${{ env.AWS_REGION }}
          
        # Wait for update to complete
        aws lambda wait function-updated \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --region ${{ env.AWS_REGION }}
          
    - name: üß™ Test deployment
      run: |
        # Get function URL or API Gateway endpoint
        FUNCTION_URL=$(aws lambda get-function-url-config \
          --function-name ${{ env.LAMBDA_FUNCTION_NAME }} \
          --query FunctionUrl \
          --output text \
          --region ${{ env.AWS_REGION }} 2>/dev/null || echo "")
          
        if [ -n "$FUNCTION_URL" ]; then
          echo "Testing Lambda Function URL: $FUNCTION_URL"
          curl -f "$FUNCTION_URL" || exit 1
        else
          echo "Testing API Gateway endpoint..."
          # Construct API Gateway URL (adjust if needed)
          API_ID=$(aws apigateway get-rest-apis \
            --query "items[?name=='fitlog-dev-api'].id" \
            --output text \
            --region ${{ env.AWS_REGION }})
          if [ -n "$API_ID" ]; then
            curl -f "https://${API_ID}.execute-api.${{ env.AWS_REGION }}.amazonaws.com/dev" || exit 1
          fi
        fi
        
    - name: üìä Get API Gateway URL for E2E tests
      id: get-api-url
      run: |
        # Try to get API Gateway ID from Terraform outputs first
        API_ID=""
        if [ -f "infrastructure/terraform.tfstate" ]; then
          API_ID=$(cat infrastructure/terraform.tfstate | jq -r '.outputs.api_gateway_url.value // empty' | sed 's|https://||' | sed 's|\.execute-api.*||')
        fi
        
        # Fallback to AWS CLI if Terraform output not available
        if [ -z "$API_ID" ]; then
          API_ID=$(aws apigateway get-rest-apis \
            --query "items[?name=='fitlog-dev-api'].id" \
            --output text \
            --region ${{ env.AWS_REGION }})
        fi
        
        if [ -n "$API_ID" ] && [ "$API_ID" != "None" ]; then
          API_URL="https://${API_ID}.execute-api.${{ env.AWS_REGION }}.amazonaws.com/dev"
          echo "api_id=$API_ID" >> $GITHUB_OUTPUT
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ API Gateway URL: $API_URL"
        else
          echo "‚ùå Could not determine API Gateway URL"
          exit 1
        fi
        
    - name: üìä Report deployment
      if: success()
      run: |
        echo "‚úÖ Deployment successful!"
        echo "üîó API Gateway: ${{ steps.get-api-url.outputs.api_url }}"
        echo "üì¶ Function: ${{ env.LAMBDA_FUNCTION_NAME }}"
        echo "üåé Region: ${{ env.AWS_REGION }}"

  e2e-tests:
    name: üß™ End-to-End Tests
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    
    steps:
    - name: üì• Checkout code
      uses: actions/checkout@v4
      
    - name: üêç Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: ‚öôÔ∏è Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: üì¶ Install test dependencies
      run: |
        curl -LsSf https://astral.sh/uv/install.sh | sh
        echo "$HOME/.local/bin" >> $GITHUB_PATH
        uv venv
        source .venv/bin/activate
        uv pip install pytest requests
        
    - name: üîç Get API Gateway URL
      id: get-api-url
      run: |
        # Get API Gateway ID
        API_ID=$(aws apigateway get-rest-apis \
          --query "items[?name=='fitlog-dev-api'].id" \
          --output text \
          --region ${{ env.AWS_REGION }})
          
        if [ -n "$API_ID" ] && [ "$API_ID" != "None" ]; then
          API_URL="https://${API_ID}.execute-api.${{ env.AWS_REGION }}.amazonaws.com/dev"
          echo "api_url=$API_URL" >> $GITHUB_OUTPUT
          echo "‚úÖ Found API Gateway: $API_URL"
        else
          echo "‚ùå Could not find API Gateway"
          exit 1
        fi
        
    - name: ‚è±Ô∏è Wait for API to be ready
      run: |
        echo "üïê Waiting for API to be fully deployed and ready..."
        API_URL="${{ steps.get-api-url.outputs.api_url }}"
        
        # Wait up to 5 minutes for the API to be ready
        for i in {1..30}; do
          if curl -s --max-time 10 "$API_URL/" > /dev/null 2>&1; then
            echo "‚úÖ API is responding after ${i}0 seconds"
            break
          else
            echo "‚è≥ Waiting for API... (attempt $i/30)"
            sleep 10
          fi
          
          if [ $i -eq 30 ]; then
            echo "‚ùå API did not become ready within 5 minutes"
            exit 1
          fi
        done
        
    - name: üöÄ Run smoke test
      run: |
        source .venv/bin/activate
        python tests/e2e/run_e2e_tests.py \
          --api-url "${{ steps.get-api-url.outputs.api_url }}" \
          --smoke-only \
          --verbose
          
    - name: üß™ Run full E2E test suite
      run: |
        source .venv/bin/activate
        python tests/e2e/run_e2e_tests.py \
          --api-url "${{ steps.get-api-url.outputs.api_url }}" \
          --verbose
          
    - name: üìä E2E Test Summary
      if: always()
      run: |
        if [ $? -eq 0 ]; then
          echo "üéâ All E2E tests passed! API is working correctly."
        else
          echo "üí• Some E2E tests failed. Check the logs above."
          exit 1
        fi